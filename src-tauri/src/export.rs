use crate::models::*;
use chrono::Utc;
use serde_json;
use std::fs;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ExportError {
    #[error("Failed to write file: {0}")]
    FileWriteError(#[from] std::io::Error),
    #[error("Failed to serialize data: {0}")]
    SerializationError(#[from] serde_json::Error),
    #[error("Unsupported export format: {0:?}")]
    UnsupportedFormat(ExportFormat),
    #[error("Invalid file path: {0}")]
    InvalidPath(String),
}

pub struct ExportManager;

impl ExportManager {
    pub fn new() -> Self {
        Self
    }

    pub fn export_calculation(
        &self,
        calculation: &CalculationResult,
        format: ExportFormat,
        file_path: Option<String>,
    ) -> Result<String, ExportError> {
        let timestamp = Utc::now().format("%Y-%m-%d %H:%M:%S UTC").to_string();
        
        let export_data = ExportData {
            calculation: calculation.clone(),
            timestamp: timestamp.clone(),
            format: format.clone(),
        };

        match format {
            ExportFormat::Json => self.export_json(&export_data, file_path),
            ExportFormat::Csv => self.export_csv(&export_data, file_path),
            ExportFormat::Pdf => self.export_pdf(&export_data, file_path),
        }
    }

    fn export_json(&self, data: &ExportData, file_path: Option<String>) -> Result<String, ExportError> {
        let json_content = serde_json::to_string_pretty(data)?;
        
        if let Some(path) = file_path {
            fs::write(&path, &json_content)?;
            Ok(format!("Exported to JSON file: {}", path))
        } else {
            Ok(json_content)
        }
    }

    fn export_csv(&self, data: &ExportData, file_path: Option<String>) -> Result<String, ExportError> {
        let calc = &data.calculation;
        
        let mut csv_content = String::new();
        csv_content.push_str("Field,Value\n");
        csv_content.push_str(&format!("Export Timestamp,{}\n", data.timestamp));
        csv_content.push_str(&format!("Film,{}\n", calc.film_name));
        csv_content.push_str(&format!("Developer,{}\n", calc.developer_name));
        csv_content.push_str(&format!("Film Type,{:?}\n", calc.film_type));
        csv_content.push_str(&format!("Development Time,{}\n", calc.time_formatted));
        csv_content.push_str(&format!("Development Time (minutes),{}\n", calc.time_minutes));
        csv_content.push_str(&format!("Temperature,{}°C\n", calc.temperature));
        csv_content.push_str(&format!("Push/Pull,{} stops\n", calc.push_pull));
        csv_content.push_str(&format!("Dilution,{}\n", calc.dilution));
        csv_content.push_str(&format!("Developer Amount,{} ml\n", calc.developer_amount));
        csv_content.push_str(&format!("Water Amount,{} ml\n", calc.water_amount));
        
        if !calc.notes.is_empty() {
            csv_content.push_str(&format!("Notes,\"{}\"\n", calc.notes.join("; ")));
        }

        if let Some(path) = file_path {
            fs::write(&path, &csv_content)?;
            Ok(format!("Exported to CSV file: {}", path))
        } else {
            Ok(csv_content)
        }
    }

    fn export_pdf(&self, data: &ExportData, file_path: Option<String>) -> Result<String, ExportError> {
        // For now, we'll create a simple text-based PDF content
        // In a full implementation, you'd use a PDF library like printpdf
        let calc = &data.calculation;
        
        let pdf_content = format!(
            "DARKROOM PRO - DEVELOPMENT CALCULATION REPORT\n\
            =============================================\n\n\
            Export Date: {}\n\n\
            FILM DETAILS:\n\
            Film: {}\n\
            Type: {:?}\n\n\
            DEVELOPER DETAILS:\n\
            Developer: {}\n\
            Dilution: {}\n\n\
            CALCULATION PARAMETERS:\n\
            Temperature: {}°C\n\
            Push/Pull: {} stops\n\
            Solution Volume: {} ml\n\n\
            RESULTS:\n\
            Development Time: {} ({})\n\
            Developer Amount: {} ml\n\
            Water Amount: {} ml\n\n\
            NOTES:\n\
            {}\n\n\
            Generated by DarkroomPro v1.0.2\n\
            Professional Film Development Calculator",
            data.timestamp,
            calc.film_name,
            calc.film_type,
            calc.developer_name,
            calc.dilution,
            calc.temperature,
            calc.push_pull,
            calc.developer_amount + calc.water_amount,
            calc.time_formatted,
            calc.time_minutes,
            calc.developer_amount,
            calc.water_amount,
            if calc.notes.is_empty() { "None".to_string() } else { calc.notes.join("\n") }
        );

        if let Some(path) = file_path {
            fs::write(&path, &pdf_content)?;
            Ok(format!("Exported to text file: {} (PDF generation requires additional libraries)", path))
        } else {
            Ok(pdf_content)
        }
    }

    pub fn export_database_summary(
        &self,
        films: &[&Film],
        developers: &[&Developer],
        file_path: Option<String>,
    ) -> Result<String, ExportError> {
        let timestamp = Utc::now().format("%Y-%m-%d %H:%M:%S UTC").to_string();
        
        let mut content = String::new();
        content.push_str("DARKROOM PRO - DATABASE SUMMARY\n");
        content.push_str("===============================\n\n");
        content.push_str(&format!("Export Date: {}\n\n", timestamp));
        
        content.push_str(&format!("FILMS ({} total):\n", films.len()));
        content.push_str("----------------\n");
        for film in films {
            content.push_str(&format!(
                "• {} (ISO {}, {:?}) - {} developers available\n",
                film.name,
                film.iso,
                film.film_type,
                film.developers.len()
            ));
        }
        
        content.push_str(&format!("\n\nDEVELOPERS ({} total):\n", developers.len()));
        content.push_str("---------------------\n");
        for dev in developers {
            content.push_str(&format!(
                "• {} by {} ({})\n",
                dev.name,
                dev.manufacturer,
                dev.developer_type
            ));
        }
        
        content.push_str("\n\nGenerated by DarkroomPro v1.0.2\n");

        if let Some(path) = file_path {
            fs::write(&path, &content)?;
            Ok(format!("Database summary exported to: {}", path))
        } else {
            Ok(content)
        }
    }
}